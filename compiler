#!/bin/bash

# output header for oroot hook + overlay_flush header
cat <<EOF > oroot
#!/bin/ash
  if [ "\${oroot}" ]; then
     fsck_root() {
       echo &>/dev/null
     }
   if [ ! -b "/dev/zram0" ]; then
      modprobe zram num_devices=\$((\$(nproc)+2))
   fi
   echo "#!/bin/bash
         mkdir /run/oroot
EOF

# generate part of the overlay_flush script
genOverlayFlush() {
  read b
  # sort the kernel cmdline parameters alphabetically
  for a in $(sort <(for c in $b; do echo $c; done)); do
    case "$a" in
      cryptdevice*UUID*)
        crypt_root="${a#cryptdevice=UUID=}"
        cat <<EOF >> oroot
         if [ \"\$oroot\" = \"live\" ]; then
            cryptsetup open --uuid=\"${crypt_root%:*}\" \"${crypt_root#*:}\" \\
EOF
        ;;
      cryptdevice)
        crypt_root="${a#cryptdevice=}"
        cat <<EOF >> oroot
         if [ \"\$oroot\" = \"live\" ]; then
            cryptsetup open \"${crypt_root%:*}\" \"${crypt_root#*:}\" \\
EOF
        ;;
      cryptkey*UUID)
        cryptkey_root="${a#cryptkey=UUID=}"
        cat <<EOF >> oroot
              --key-file \\\$(mkdir \"/run/oroot-key\"; mount -U \"${cryptkey_root%%:*}\" \"/run/oroot-key\"; echo \"/run/oroot${cryptkey_root##*:}\")
         fi
EOF
        unset cryptkey_root
        ;;
      cryptkey*)
        cryptkey_root="${a#cryptkey=}"
        cat <<EOF >> oroot
              --key-file \\\$(mkdir \"/run/oroot-key\"; mount \"${cryptkey_root%%:*}\" \"/run/oroot-key\"; echo \"/run/oroot${cryptkey_root##*:}\")
EOF
        unset cryptkey_root
        ;;
      root*UUID*)
        # need to newline before fi for cryptsetup to break \
        if [ "$crypt_root" ]; then
        cat <<EOF >> oroot
        
         fi
         mount -U \"${a#root=UUID=}\" \\
EOF
          else
        cat <<EOF >> oroot
         mount -U \"${a#root=UUID=}\" \\
EOF
        fi
        ;;
      root*)
        if [ "$crypt_root" ]; then
        cat <<EOF >> oroot
        
         fi
         mount --source \"${a#root=}\" \\
EOF
         else
        cat <<EOF >> oroot        
         mount --source \"${a#root=}\" \\
EOF
        fi
        ;;
    esac
  done
  unset b
}

# interpret kernel cmdline options and pass to above loop
genOverlayFlush </proc/cmdline

# rsync code + clean up code for overlay_flush
cat <<EOF >> oroot
           -o $(awk '{if ($2 == "/") {print $4}}' /etc/fstab) \"/run/oroot\"
         rsync -a --delete / /run/oroot --exclude bin --exclude boot --exclude dev \\
           --exclude lib --exclude lib64 --exclude mnt --exclude proc --exclude run \\
           --exclude sbin --exclude sys --exclude tmp --exclude usr/bin/overlay_flush;
         umount /run/oroot;
         rm -r /run/oroot;
EOF

# close the device in overlay_flush
closeOverlayFlush() {
  read b
  for a in "$@"; do
    case "$a" in
      cryptkey*)
        cat <<EOF >> oroot
         if [ \"\$oroot\" = \"live\" ]; then
            umount \"/run/oroot-key\"
            rm -r \"/run/oroot-key\"
         fi
EOF
        ;;
      cryptdevice*UUID*)
        cat <<EOF >> oroot
         if [ \"\$oroot\" = \"live\" ]; then
            cryptsetup close \"${a#cryptdevice=UUID=*:}\"
         fi
EOF
        ;;
      cryptdevice*)
        cat <<EOF >> oroot
         if [ \"\$oroot\" = \"live\" ]; then
            cryptsetup close \"${a#cryptdevice=*:}\"
         fi
EOF
        ;;
    esac
  done;
  unset b
}

# interpret kernel cmdline options and pass to above loop
closeOverlayFlush </proc/cmdline

# setuid for overlay_flush and mount root
cat <<EOF >> oroot
         " > /overlay_flush
     chmod ug+x /overlay_flush
     poll_device "\$root" 20;
     "\$mount_handler" /lroot;
EOF

# read $oroot and generate ram device
cat <<EOF >> oroot
     case "\$oroot" in
        live|compressed)
          zdevice=\$(zramctl -f -s \$(awk '/Mem/ {print int(\$2*2)}' <<(free -m))M -a lzo -t \$(nproc))
          mkfs.ext2 "\$zdevice"
          mount "\$zdevice" /troot
          export zdevice
          if [ "\$oroot" = "live" ]; then
             cp -a /lroot/* /troot/
EOF

# close device if oroot=live
closeDevice() {
  read b
  for a in "$@"; do
    case "$a" in
      cryptdevice*UUID*)
        cat <<EOF >> oroot
             cryptsetup close "${a#cryptdevice=UUID=*:}"
EOF
        ;;
      cryptdevice*)
        cat <<EOF >> oroot
             cryptsetup close "${a#cryptdevice=*:}"
EOF
        ;;
    esac
  done
  unset b
}

closeDevice </proc/cmdline

# finish setting up ram device
cat <<EOF >>oroot
             oroot_mount() {
               mount "\$zdevice" "\$1"
               mv /overlay_flush /\$1/usr/bin/
             }
           else
             mkdir /troot/upper /troot/work
             oroot_mount() {
               mount oroot -t overlay -o lowerdir=/lroot,upperdir=/troot/upper,workdir=/troot/work "\$1"
               mv /overlay_flush /\$1/usr/bin/
             }
          fi
          ;;
        *)
          mount troot -t tmpfs -o size=\$(awk '/Mem/ {print int(\$2*2)}' <<(free -m))M /troot
          oroot_mount() {
            mount oroot -t overlay -o lowerdir=/lroot,upperdir=/troot/upper,workdir=/troot/work "\$1"
            mv /overlay_flush /\$1/usr/bin/
          }
          ;;
     esac
EOF

# close oroot hook
cat <<EOF >> oroot
     mount_handler=oroot_mount
  fi;
}
EOF